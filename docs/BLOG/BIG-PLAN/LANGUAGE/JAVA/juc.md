# JUC 知识点

## concurentHashmap

### 1.8以前

#### 基本原理

1. 通过segment对象内部切分成多个独立的小map，减少锁的粒度
2. 通过AOS实现的线程安全，底层是CAS

### 1.8以后

#### 基本原理

1. 锁粒度再次细化，单次锁桶的第一个节点（单个桶）
2. 链表长度超过8个升级为红黑树
3. 渐进式扩容，查询线程辅助扩容
4. 底层还是通过AOS实现的线程安全，但是更细粒度

#### 5种类型

Node        基本的桶
TreeNode    红黑树
TreeBin     封装了红黑树，带锁 + waiter + 状态的结构
FowardNode  搬迁完成的占位节点，保存了新的桶地址
Holder      占位用，当桶的位置为null时，又需要加锁的时候临时使用      

#### 查询

查询保证无锁，但代价是如果查询的节点退化为红黑树后，依旧通过链表指针进行O(n)的遍历，因为在删除节点的时候，被删除节点的指向并没有删除，也就意味着被删除节点所指向的节点，有两个节点同时指向（新和旧），意味着可以无锁进行查询，但代价是O(N)

正常情况下如果查询的节点是链表，直接遍历查询，不加锁

#### 写入

写入时，如果没有读，通过CAS获取到锁，将状态改为写入中，开始写入
写入时，如果发现有读，会将自己挂起(park)，保存在wait变量中，等待读结束（通过内置的状态变量判断）
当最后一个读线程读完后，会唤醒写线程（手动unpark），写线程重复第一步的判断

#### 扩容

写入某个桶到达扩容阈值后，开始扩容
扩容没完成时，旧桶内容不动，复制一份全新的副本到新的桶，大小*2
查询时，直接查询当前桶，即使在搬迁也有全量数据
写入时，若发现当前桶在搬迁，则开始辅助搬迁，搬迁完成后进行写入操作

## 锁

### syncnize

锁方法是通过修改方法区的标志位
锁代码块是通过注入字节码屏障的方式实现的（monitorEnter,monitorExit)


内置三种锁，偏向锁，轻量级锁，重量级锁

偏向锁通过在class内维护一个偏向锁撤销计数器实现的，有批量冲偏向和撤销偏向操作。都是打到阈值后触发。
当有第二个现场来获取锁的时候，升级到轻量级锁，此时通过CAS自旋加锁，主要场景是竞争不激烈（自旋主要规避了内核上下文切换的开销）
当CAS自旋次数到达阈值后，升级为重量级锁，表示此时竞争激烈，ObjectMointor

### RetrenLock



